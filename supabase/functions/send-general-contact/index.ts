// Deno Edge Function環境用 - TypeScriptエラーは実行時には問題ありません
import "jsr:@supabase/functions-js/edge-runtime.d.ts"; // 標準の型定義を利用
import { createClient, SupabaseClient } from "https://esm.sh/@supabase/supabase-js@2";

// Type Aliases
type EmailAddr = string;

// Interfaces
interface GeneralContactFormData {
  senderName: string;
  senderEmail: EmailAddr;
  subject: string;
  message: string;
}

interface MailLog {
  id?: string; // UUID, auto-generated by DB or client
  sender_name?: string;
  sender_email?: EmailAddr;
  recipient_type: "admin" | "sender" | "system"; // Added "system" for general errors
  to_email: EmailAddr;
  subject?: string;
  status_code: number;
  resend_id?: string | null; // Added as per AI review
  resend_response_body?: string | null;
  error_message?: string | null;
  created_at?: string; // ISO string, auto-generated by DB
}

// Environment Variables & Validation
const SUPABASE_URL = Deno.env.get("SUPABASE_URL");
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");
const RESEND_API_KEY = Deno.env.get("RESEND_API_KEY");
const RESEND_FROM_ADDRESS = Deno.env.get("RESEND_FROM_ADDRESS");
const ADMIN_EMAIL_TO = Deno.env.get("ADMIN_EMAIL_ADDRESS") || "piano.rythmique.find@gmail.com";

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY || !RESEND_API_KEY || !RESEND_FROM_ADDRESS) {
  const missingVars = [
    !SUPABASE_URL ? "SUPABASE_URL" : null,
    !SUPABASE_SERVICE_ROLE_KEY ? "SUPABASE_SERVICE_ROLE_KEY" : null,
    !RESEND_API_KEY ? "RESEND_API_KEY" : null,
    !RESEND_FROM_ADDRESS ? "RESEND_FROM_ADDRESS" : null,
  ].filter(Boolean).join(", ");
  console.error(`[StartupError] Missing required environment variables: ${missingVars}. Function cannot start.`);
  throw new Error(`Missing required environment variables: ${missingVars}. Function cannot start.`);
}

// Initialize Supabase Admin Client
const supabaseAdmin: SupabaseClient = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

// Helper Functions
async function recordMailLog(logEntry: Omit<MailLog, "id" | "created_at">): Promise<void> {
  try {
    const { error } = await supabaseAdmin.from('mail_logs').insert([{
      ...logEntry,
      id: crypto.randomUUID(),
      created_at: new Date().toISOString(),
    }]);
    if (error) {
      console.error("[MailLogError] Error saving mail log to Supabase:", error.message);
    }
  } catch (e: unknown) { // Catch as unknown
    console.error("[MailLogError] Exception saving mail log to Supabase:", e instanceof Error ? e.message : String(e));
  }
}

// Regex for email validation (allows for Name <email@example.com> format, simplified)
// Original suggestion: /^[^<>@\\s]+@[^<>@\\s]+\\.[^<>@\\s]+$/
// Allowing < >: /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/
// Simpler version for now, focusing on basic structure and not full RFC compliance.
const simpleEmailRegex = /^(?:[\w!#$%&\'*+/=?`{|}~^.-]+@(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}|(?:[^<>@\\s]+)\s*<[\w!#$%&\'*+/=?`{|}~^.-]+@(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}>)$/i;

const isValidEmailFormat = (email: string): boolean => {
  if (!email) return false;
  return simpleEmailRegex.test(email.trim());
};

function stripHtml(html: string): string {
  return html.replace(/<[^>]*>?/gm, ''); // Basic HTML tag stripping
}

// Deno.serve を使用する
Deno.serve(async (req: Request) => {
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
  };

  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  let preliminaryLogDetails: Partial<MailLog> & Pick<MailLog, 'recipient_type' | 'to_email'> = {
    recipient_type: "system",
    to_email: ADMIN_EMAIL_TO
  };

  try {
    if (RESEND_FROM_ADDRESS.includes('onboarding@resend.dev')) {
        console.warn('[SecurityWarning] Using default onboarding@resend.dev as RESEND_FROM_ADDRESS. This will have sending limitations and is not recommended for production. Please configure a verified domain on Resend.');
    }

    const { senderName, senderEmail, subject, message }: GeneralContactFormData = await req.json();
    // Update log details with richer info, ensuring required fields for logging are present
    preliminaryLogDetails = { 
        ...preliminaryLogDetails, 
        sender_name: senderName, 
        sender_email: senderEmail, 
        subject, 
        recipient_type: "admin", // Default to admin context first
        to_email: ADMIN_EMAIL_TO
    };

    if (!senderName || !senderEmail || !subject || !message) {
      return new Response(JSON.stringify({ success: false, message: '必須フィールドが不足しています。' }), 
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    if (!isValidEmailFormat(senderEmail)) {
      await recordMailLog({ ...preliminaryLogDetails, status_code: 400, error_message: `Invalid senderEmail format: ${senderEmail}` });
      return new Response(JSON.stringify({ success: false, message: '入力されたメールアドレスの形式が正しくありません。' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    const textContentForEmail = stripHtml(message);
    // Ensure HTML content uses variables correctly
    const toAdminHtml = `<p>${message}</p>`; // Example, replace with actual rich HTML
    const toSenderHtml = `<p>Thank you, ${senderName}. We received: ${message}</p>`; // Example

    const fetchTimeoutMs = 10000;

    let adminEmailSent = false;
    try {
      const adminSignal = AbortSignal.timeout(fetchTimeoutMs);
      const adminEmailResponse = await fetch('https://api.resend.com/emails', {
        signal: adminSignal,
        method: 'POST',
        headers: { 'Authorization': `Bearer ${RESEND_API_KEY}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          from: RESEND_FROM_ADDRESS,
          to: [ADMIN_EMAIL_TO],
          reply_to: [`${senderName} <${senderEmail}>`],
          subject: `【ピアノサーチ】${subject}`,
          html: toAdminHtml,
          text: `お問い合わせがありました。\n件名: ${subject}\nお名前: ${senderName}\nメールアドレス: ${senderEmail}\n\n内容:\n${textContentForEmail}`,
        }),
      });
      const adminResBody = await adminEmailResponse.json().catch(() => ({})); 
      const adminResendId = adminResBody.id || null;
      await recordMailLog({ 
          ...preliminaryLogDetails, 
          status_code: adminEmailResponse.status, 
          resend_id: adminResendId,
          resend_response_body: JSON.stringify(adminResBody),
          error_message: adminEmailResponse.ok ? null : adminResBody.message || `Admin email send failed (HTTP ${adminEmailResponse.status})`
      });
      adminEmailSent = adminEmailResponse.ok;
    } catch (e: unknown) { // Catch as unknown
        console.error("[ResendAdminError]", e instanceof Error ? e.message : String(e));
        await recordMailLog({ 
            ...preliminaryLogDetails, 
            status_code: (e instanceof Error && e.name === 'TimeoutError') ? 408 : 500, 
            error_message: e instanceof Error ? e.message : String(e)
        });
    }

    let senderEmailSent = false;
    // Only attempt to send to sender if admin email was (seemingly) successful
    // Or if you want to attempt both regardless: remove `if (adminEmailSent)`
    if (adminEmailSent) { 
        try {
            const senderSignal = AbortSignal.timeout(fetchTimeoutMs);
            const senderEmailResponse = await fetch('https://api.resend.com/emails', {
                signal: senderSignal,
                method: 'POST',
                headers: { 'Authorization': `Bearer ${RESEND_API_KEY}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    from: RESEND_FROM_ADDRESS,
                    to: [senderEmail],
                    subject: '【ピアノサーチ】お問い合わせを受け付けました',
                    html: toSenderHtml,
                    text: `${senderName} 様\n\nお問い合わせありがとうございます。以下の内容で受け付けました。\n件名: ${subject}\nお名前: ${senderName}\nメールアドレス: ${senderEmail}\n\n内容:\n${textContentForEmail}`,
                }),
            });
            const senderResBody = await senderEmailResponse.json().catch(() => ({}));
            const senderResendId = senderResBody.id || null;
            await recordMailLog({
                // Update log details for sender context
                sender_name: senderName, 
                sender_email: senderEmail, 
                subject: '【ピアノサーチ】お問い合わせを受け付けました', 
                recipient_type: "sender", 
                to_email: senderEmail, 
                status_code: senderEmailResponse.status, 
                resend_id: senderResendId,
                resend_response_body: JSON.stringify(senderResBody),
                error_message: senderEmailResponse.ok ? null : senderResBody.message || `Sender email send failed (HTTP ${senderEmailResponse.status})`
            });
            senderEmailSent = senderEmailResponse.ok;
        } catch (e: unknown) { // Catch as unknown
            console.error("[ResendSenderError]", e instanceof Error ? e.message : String(e));
            await recordMailLog({ 
                sender_name: senderName, 
                sender_email: senderEmail, 
                subject: '【ピアノサーチ】お問い合わせを受け付けました', 
                recipient_type: "sender", 
                to_email: senderEmail, 
                status_code: (e instanceof Error && e.name === 'TimeoutError') ? 408 : 500, 
                error_message: e instanceof Error ? e.message : String(e) 
            });
        }
    }

    const clientStatus = 500; // Default to 500, can be refined

    if (adminEmailSent && senderEmailSent) {
      return new Response(JSON.stringify({ success: true, message: 'お問い合わせを送信しました。確認メールをご確認ください。' }),
        { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    } else {
      return new Response(JSON.stringify({
          success: false,
          message: 'メール送信に一部失敗しました。お手数ですが、時間をおいて再度お試しいただくか、管理者にご連絡ください。',
          detail: `Admin dispatch: ${adminEmailSent}, Sender dispatch: ${senderEmailSent}. Check server logs for details.`
        }),
        { status: clientStatus, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

  } catch (error: unknown) { // Catch as unknown
    console.error("[CriticalMainError]", error instanceof Error ? error.message : String(error));
    // Ensure all required fields for MailLog are present even in critical error
    const finalLogDetails: Omit<MailLog, "id" | "created_at"> = {
        sender_name: preliminaryLogDetails.sender_name || "N/A",
        sender_email: preliminaryLogDetails.sender_email || "N/A",
        recipient_type: preliminaryLogDetails.recipient_type || "system",
        to_email: preliminaryLogDetails.to_email, // Already Picked, so it exists
        subject: preliminaryLogDetails.subject || "Critical Error Notification",
        status_code: 500, 
        error_message: error instanceof Error ? error.message : String(error) 
    };
    await recordMailLog(finalLogDetails);
    return new Response(JSON.stringify({ success: false, message: '予期せぬエラーが発生しました。' }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
  }
}); 